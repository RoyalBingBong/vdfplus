!function(f){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=f();else if("function"==typeof define&&define.amd)define([],f);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).VDF=f()}}(function(){return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a="function"==typeof require&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n||e)},l,l.exports,e,t,n,r)}return n[o].exports}for(var i="function"==typeof require&&require,o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){"use strict";function _parse(str,types=!0,currentLine){let obj={},line=currentLine||1,openBracket=!1,bracketCount=0,openQuote=!1,startComment=!1,potentialComment=!1,globalBrackets=0,globalQuotes=0,expectKey=!0,expectValue=!1,currentKey="",currentValue="";for(let i=0;i<str.length;i++){let char=str[i];if('"'!=char||openBracket){if("{"==char&&!openQuote){if(bracketCount++,globalBrackets++,expectKey)throw new SyntaxError(`Unexpected token ${char} in VDF in line ${line}`);if(expectValue&&!openBracket){openBracket=!0;continue}if(!expectValue)continue}if("}"==char&&!openQuote){if(bracketCount--,globalBrackets--,openBracket&&0==bracketCount&&(openBracket=!1,expectValue)){let value=_parse(currentValue,types,line);currentKey in obj?Array.isArray(obj[currentKey])?obj[currentKey].push(value):obj[currentKey]=[obj[currentKey],value]:obj[currentKey]=value,currentKey="",currentValue="",expectKey=!0,expectValue=!1}if(!expectValue)continue}if("\n"==char&&(line++,startComment&&(startComment=!1)),expectKey&&openQuote)currentKey+=char;else if(expectValue&&(openQuote||openBracket))currentValue+=char;else if(!("/"!=char||openQuote&&openBracket)){if(startComment)continue;if(!potentialComment){potentialComment=!0;continue}if(str[i-1]&&"/"==str[i-1]){potentialComment=!1,startComment=!0;continue}}}else{if(str[i-1]&&"\\"==str[i-1]){expectKey&&(currentKey+=char),expectValue&&(currentValue+=char);continue}if(openQuote){if(openQuote=!1,globalQuotes--,expectKey){expectKey=!1,expectValue=!0;continue}expectValue&&(expectKey=!0,expectValue=!1,types&&(TYPEEX.INT.test(currentValue)?currentValue=parseInt(currentValue):TYPEEX.FLOAT.test(currentValue)?currentValue=parseFloat(currentValue):TYPEEX.BOOLEAN.test(currentValue)&&(currentValue="true"==currentValue.toLowerCase())),currentKey in obj?Array.isArray(obj[currentKey])?obj[currentKey].push(currentValue):obj[currentKey]=[obj[currentKey],currentValue]:obj[currentKey]=currentValue,currentKey="",currentValue="")}else openQuote=!0,globalQuotes++}}if(globalBrackets>0){let bracket=globalBrackets>1?"brackets":"bracket";throw new SyntaxError(`VDF seems to be malformed. Found ${globalBrackets} unclosed ${bracket}.`)}if(globalQuotes>0){let quote=globalBrackets>1?"quotes":"quote";throw new SyntaxError(`VDF seems to be malformed. Found ${globalQuotes} unclosed ${quote}.`)}return obj}function serialize(key,obj,whitespace,indentation,separator,linebreak){let value=obj[key],prefix=indentation;if(indentation+=whitespace,"object"!=typeof value)return quote(""+value);{let results=[];for(let subKey in value)if(Array.isArray(value[subKey])){let arr=value[subKey];for(let i=0;i<arr.length;i++){let elem=serialize(i,arr,whitespace,indentation,separator,linebreak);"object"==typeof arr[i]?results.push(`${quote(subKey)}${whitespace}{${linebreak}${indentation}${elem}${linebreak}${prefix}}`):results.push(`${quote(subKey)}${separator}${elem}`)}}else if("object"==typeof value[subKey]){let elem=serialize(subKey,value,whitespace,indentation,separator,linebreak);results.push(`${quote(subKey)}${separator}{${linebreak}${indentation}${elem}${linebreak}${prefix}}`)}else{let elem=serialize(subKey,value,whitespace,indentation,separator,linebreak);results.push(`${quote(subKey)}${separator}${elem}`)}return results.join(`${linebreak}${prefix}`)}}function quote(str){return`"${str}"`}Object.defineProperty(exports,"__esModule",{value:!0});const TYPEEX={INT:/^\d+$/,FLOAT:/^\d+\.\d+$/,BOOLEAN:/true|false/i};exports.parse=function(str,types=!0){if("string"!=typeof str)throw new TypeError(`Expecting parameter to be string, received ${typeof str}`);return _parse(str,types,1)},exports.stringify=function(value,indentation,separator){if(!value||"object"!=typeof value)throw new TypeError(`Expected object got ${typeof value}`);let gap,sep,lineBreak="\n";if("number"==typeof indentation)gap="".padStart(Math.min(indentation,10));else if("string"==typeof indentation)if(""==indentation)lineBreak=" ",gap=" ";else{if(!/^\s+$/.test(indentation))throw new TypeError("indentation has to be a string containing only whitespace characters");gap=indentation.substring(0,10)}else gap="  ";if("number"==typeof separator)sep="".padStart(Math.min(separator,10));else if("string"==typeof separator){if(!/^\s+$/.test(separator))throw new TypeError("separator has to be a string containing only whitespace characters");sep=separator}else sep="\t";let dataObject={};return dataObject[""]=value,serialize("",dataObject,gap,"",sep,lineBreak)}},{}]},{},[1])(1)});