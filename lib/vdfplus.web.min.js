!function(f){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=f();else if("function"==typeof define&&define.amd)define([],f);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).VDF=f()}}(function(){return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a="function"==typeof require&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n||e)},l,l.exports,e,t,n,r)}return n[o].exports}for(var i="function"==typeof require&&require,o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){"use strict";function _parse(str,types=!0,currentLine){let obj={},line=currentLine||1,openBracket=!1,bracketCount=0,openQuote=!1,startComment=!1,potentialComment=!1,globalBrackets=0,globalQuotes=0,expectKey=!0,expectValue=!1,currentKey="",currentValue="";for(let i=0;i<str.length;i++){let char=str[i];if('"'!=char||openBracket){if("{"==char&&!openQuote){if(bracketCount++,globalBrackets++,expectKey)throw new SyntaxError(`Unexpected token '${char}' at line ${line}"`);if(expectValue&&!openBracket){openBracket=!0;continue}if(!expectValue)continue}if("}"==char&&!openQuote){if(bracketCount--,globalBrackets--,openBracket&&0==bracketCount&&(openBracket=!1,expectValue)){let value=_parse(currentValue,types,line);currentKey in obj?Array.isArray(obj[currentKey])?obj[currentKey].push(value):obj[currentKey]=[obj[currentKey],value]:obj[currentKey]=value,currentKey="",currentValue="",expectKey=!0,expectValue=!1}if(!expectValue)continue}if("\n"==char&&(line++,startComment&&(startComment=!1)),expectKey&&openQuote)currentKey+=char;else if(expectValue&&(openQuote||openBracket))currentValue+=char;else if(!("/"!=char||openQuote&&openBracket)){if(startComment)continue;if(!potentialComment){potentialComment=!0;continue}if(str[i-1]&&"/"==str[i-1]){potentialComment=!1,startComment=!0;continue}}}else{if(str[i-1]&&"\\"==str[i-1]){expectKey&&(currentKey+=char),expectValue&&(currentValue+=char);continue}if(openQuote){if(openQuote=!1,globalQuotes--,expectKey){expectKey=!1,expectValue=!0;continue}expectValue&&(expectKey=!0,expectValue=!1,types&&(TYPEEX.INT.test(currentValue)?currentValue=parseInt(currentValue):TYPEEX.FLOAT.test(currentValue)?currentValue=parseFloat(currentValue):TYPEEX.BOOLEAN.test(currentValue)&&(currentValue="true"==currentValue.toLowerCase())),currentKey in obj?Array.isArray(obj[currentKey])?obj[currentKey].push(currentValue):obj[currentKey]=[obj[currentKey],currentValue]:obj[currentKey]=currentValue,currentKey="",currentValue="")}else openQuote=!0,globalQuotes++}}if(globalBrackets>0){let bracket=globalBrackets>1?"brackets":"bracket";throw new SyntaxError(`VDF seems to be malformed. Found ${globalBrackets} unclosed ${bracket}.`)}if(globalQuotes>0){let quote=globalBrackets>1?"quotes":"quote";throw new SyntaxError(`VDF seems to be malformed. Found ${globalQuotes} unclosed ${quote}.`)}return obj}function serialize(key,obj,whitespace,indentation,seperator){let value=obj[key],prefix=indentation;if(indentation+=whitespace,"object"!=typeof value)return quote(""+value);{let results=[];for(let subkey in value)if(Array.isArray(value[subkey])){let arr=value[subkey];for(let i=0;i<arr.length;i++){let elem=serialize(i,arr,whitespace,indentation,seperator);"object"==typeof arr[i]?results.push(`${quote(subkey)}${whitespace}{\n${indentation}${elem}\n${prefix}}`):results.push(`${quote(subkey)}${whitespace}${elem}`)}}else if("object"==typeof value[subkey]){let elem=serialize(subkey,value,whitespace,indentation,seperator);results.push(`${quote(subkey)}${whitespace}{\n${indentation}${elem}\n${prefix}}`)}else{let elem=serialize(subkey,value,whitespace,indentation,seperator);results.push(`${quote(subkey)}\t${elem}`)}return results.join(`\n${prefix}`)}}function quote(str){return`"${str}"`}const TYPEEX={INT:/^\d+$/,FLOAT:/^\d+\.\d+$/,BOOLEAN:/true|false/i};module.exports={parse:function(str,types=!0){if("string"!=typeof str)throw new TypeError(`Expecting parameter to be string, received ${typeof str}`);return _parse(str,types,1)},stringify:function(value,space,seperator){if(!value||"object"!=typeof value)throw new TypeError(`Expected object got ${typeof value}`);let gap="";if(space){if("number"==typeof space)gap="".padStart(space);else if("string"==typeof space){if(!/^\s+$/.test(space))throw new TypeError("space has to be a string containing only whitespace characters");gap=space.substring(0,10)}}else gap="  ";if(seperator){if(!/^\s+$/.test(seperator))throw new TypeError("seperator has to be a string containing only whitespace characters")}else seperator="\t";let datobject={};return datobject[""]=value,serialize("",datobject,gap,"",seperator)}}},{}]},{},[1])(1)});